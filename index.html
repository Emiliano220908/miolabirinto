<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Neon Console v20 (Precision Mode)</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    
    <style>
        /* ================= STILE MODERNO ================= */
        :root {
            --primary: #00f3ff; --secondary: #ff0055; --success: #00ff66;
            --warning: #ffcc00; --bg-dark: #0a0a12; --border: rgba(255, 255, 255, 0.1);
        }
        body { 
            font-family: 'Poppins', sans-serif; text-align: center; background-color: var(--bg-dark); 
            color: white; margin: 0; padding: 0; overflow: hidden; user-select: none;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }
        
        /* MENU */
        #main-menu {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }
        .menu-title {
            font-family: 'Orbitron', sans-serif; font-size: 60px; margin-bottom: 30px;
            color: transparent; -webkit-text-stroke: 2px var(--primary); text-shadow: 0 0 20px var(--primary);
            animation: flicker 3s infinite alternate;
        }
        #player-name-input {
            padding: 15px 25px; font-size: 22px; border-radius: 50px; border: 2px solid var(--border);
            background: rgba(0,0,0,0.5); color: white; text-align: center; width: 300px; 
            font-family: 'Orbitron', sans-serif; outline: none; box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .cards-container { display: flex; gap: 50px; }
        .game-card {
            width: 280px; height: 360px; background: rgba(255,255,255,0.05);
            border: 1px solid var(--border); border-radius: 20px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: 0.4s; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .game-card:hover { transform: translateY(-15px) scale(1.05); border-color: var(--primary); box-shadow: 0 0 30px var(--primary); }
        .card-icon { font-size: 80px; margin-bottom: 20px; }
        .card-title { font-family: 'Orbitron'; font-size: 22px; font-weight: 700; }
        .card-desc { font-size: 14px; color: #aaa; }
        
        /* PULSANTI */
        button { font-family: 'Orbitron'; text-transform: uppercase; cursor: pointer; border: none; border-radius: 30px; transition:0.2s;}
        .back-btn { position: absolute; top: 20px; left: 20px; padding: 10px 25px; background: #333; color: white; border: 1px solid #ff3333; }
        .back-btn:hover { background: #ff3333; }
        .leaderboard-btn { position: absolute; top: 20px; right: 20px; padding: 10px 25px; background: #333; color: var(--warning); border: 1px solid var(--warning); }
        .leaderboard-btn:hover { background: var(--warning); color: black; }
        .game-btn { padding: 12px 30px; font-size: 16px; background: var(--primary); color: black; font-weight: bold; }
        .small-btn { padding: 5px 10px; font-size: 12px; border-radius: 5px; color: white; background: #555; }

        /* OVERLAY E STATUS */
        #status-bar { margin-top: 50px; padding: 10px 20px; background: rgba(0,0,0,0.6); border-radius: 20px; border: 1px solid #333; display: inline-block; }
        .overlay-screen {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(16, 16, 24, 0.98); border: 1px solid white; padding: 40px; border-radius: 20px;
            z-index: 200; width: 400px; box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .scrollable-list { max-height: 250px; overflow-y: auto; margin: 20px 0; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 10px;}
        .leader-row { display: flex; justify-content: space-between; font-size: 16px; margin-bottom: 8px; border-bottom: 1px solid #333; padding: 5px; }
        .leader-rank { color: var(--primary); width: 30px; }
        .leader-name { flex-grow: 1; text-align: left; }
        .leader-score { color: var(--warning); font-family: 'Orbitron'; }
        
        .dots-menu-btn { cursor: pointer; padding: 0 5px; color: #888; }
        .dots-menu-btn:hover { color: white; }
        .dropdown-content { display: none; position: absolute; right: 20px; background: #222; border: 1px solid #555; z-index: 300; min-width: 100px;}
        .dropdown-content div { padding: 8px; cursor: pointer; text-align: left; }
        .dropdown-content div:hover { background: #444; }

        /* GIOCHI */
        #maze-wrapper, #fighter-wrapper { display: none; height: 100vh; padding-top: 20px; }
        
        #maze-info-bar { display: flex; justify-content: space-between; width: 450px; margin: 0 auto 20px auto; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 50px;}
        #maze-level-box { font-family: 'Orbitron'; font-size: 20px; color: var(--primary); }
        #maze-timer-box { font-family: 'Orbitron'; font-size: 24px; color: var(--warning); }
        
        #game-area-maze { margin: 0 auto; position: relative; background: black; display: grid; border: 2px solid #555; box-shadow: 0 0 30px rgba(0,255,0,0.2); }
        .cell { box-sizing: border-box; }
        .wall { background: #333; border: 1px solid #222; }
        .path { background: transparent; }
        .goal { background: var(--primary); animation: pulse 1s infinite alternate; }
        
        /* ANIMAZIONE PALLINO FLUIDA */
        #player-maze { 
            background: var(--success); 
            position: absolute; 
            border-radius: 50%; 
            box-shadow: 0 0 15px var(--success);
            transition: top 0.2s ease-in-out, left 0.2s ease-in-out; 
        }

        #score-board { font-family: 'Orbitron'; font-size: 30px; color: var(--secondary); margin-bottom: 10px; }
        #game-area-fighter { width: 400px; height: 500px; background: black; border: 2px solid var(--secondary); border-bottom: 4px solid red; margin: 0 auto; position: relative; overflow: hidden; box-shadow: 0 0 40px rgba(255,0,85,0.2); }
        #fighter-player { width: 30px; height: 30px; background: var(--primary); position: absolute; bottom: 20px; box-shadow: 0 0 15px var(--primary); clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .bullet { width: 4px; height: 15px; background: var(--warning); position: absolute; }
        .enemy { width: 30px; height: 30px; background: var(--secondary); position: absolute; border-radius: 3px; }

        @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        @keyframes pulse { from { transform: scale(0.9); } to { transform: scale(1.1); } }
    </style>
</head>
<body>

    <div id="main-menu">
        <div class="menu-title">ARDUINO CONSOLE</div>
        <input type="text" id="player-name-input" placeholder="NOME GIOCATORE" maxlength="8">
        <div class="cards-container" style="margin-top: 30px;">
            <div class="game-card" onclick="openGame('maze')">
                <div class="card-icon" style="color:var(--success)">üß©</div>
                <div class="card-title">LABIRINTO</div>
                <div class="card-desc">Movimento Preciso</div>
            </div>
            <div class="game-card" onclick="openGame('fighter')">
                <div class="card-icon" style="color:var(--secondary)">üöÄ</div>
                <div class="card-title">FIGHTER WAR</div>
                <div class="card-desc">Movimento Fluido</div>
            </div>
        </div>
        <div id="status-bar">
            <button id="connectBtn" class="game-btn">üîå CONNETTI USB</button>
            <div id="status" style="margin-top:10px; color:#888;">In attesa...</div>
        </div>
    </div>

    <div id="maze-wrapper">
        <button class="back-btn" onclick="goBack()">üè† MENU</button>
        <button class="leaderboard-btn" onclick="showMazeLeaderboard(true)">üèÜ RANK</button>
        <div id="maze-info-bar">
            <div id="maze-level-box">LIV <span id="maze-level-num">1</span>/5</div>
            <div id="maze-timer-box">‚è±Ô∏è <span id="maze-live-timer">00:00</span></div>
        </div>
        <div id="game-area-maze"><div id="player-maze"></div></div>
        
        <div id="maze-overlay" class="overlay-screen" style="border-color:var(--success);">
            <h2 style="color:var(--success); margin:0;">SPEEDRUN</h2>
            <div id="maze-current-time" style="color:#aaa; margin:10px 0;"></div>
            <div style="display:flex; justify-content:space-between; border-bottom:1px solid #444; padding-bottom:5px;">
                <span>TOP RECORDS</span> <button class="small-btn" onclick="clearMazeLeaderboard()" style="background:#f33;">RESET</button>
            </div>
            <div id="maze-leaderboard-list" class="scrollable-list"></div>
            <button class="game-btn" onclick="closeMazeLeaderboard()" style="width:100%">CHIUDI</button>
        </div>
    </div>

    <div id="fighter-wrapper">
        <button class="back-btn" onclick="goBack()">üè† MENU</button>
        <button class="leaderboard-btn" onclick="pauseAndShowFighterLeaderboard()">üèÜ RANK</button>
        <div id="score-board">0000</div>
        <div id="game-area-fighter">
            <div id="fighter-player"></div>
        </div>
        
        <div id="fighter-overlay" class="overlay-screen" style="border-color:var(--secondary);">
            <h2 id="fighter-overlay-title" style="color:var(--secondary); margin:0;">GAME OVER</h2>
            <div id="final-score" style="font-size:24px; font-weight:bold; margin:10px 0;"></div>
            <div style="display:flex; justify-content:space-between; border-bottom:1px solid #444; padding-bottom:5px;">
                <span>CLASSIFICA</span> <button class="small-btn" onclick="clearFighterLeaderboard()" style="background:#f33;">RESET</button>
            </div>
            <div id="fighter-leaderboard-list" class="scrollable-list"></div>
            <button id="fighter-resume-btn" class="game-btn" onclick="resumeFighter()" style="width:100%; display:none; background:var(--warning)">RIPRENDI</button>
            <button id="fighter-restart-btn" class="game-btn" onclick="restartFighter()" style="width:100%;">RIGIOCA</button>
            <button class="game-btn" onclick="goBack()" style="background:#333; width:100%; margin-top:10px;">ESCI</button>
        </div>
    </div>

    <script>
        // --- INPUT ANALOGICO ---
        let inputX = 0; 
        let inputY = 0;
        
        // ZONA MORTA AL 30% (Per evitare movimenti se non spingi bene)
        const DEADZONE = 0.30; 

        // --- GESTIONE STATO ---
        let giocoAttivo = 'menu';
        let playerName = "GUEST";
        let mazeStartTime = 0; 
        let mazeTimerInterval;
        let isFighterPaused = false;

        function openGame(gameName) {
            const inputVal = document.getElementById('player-name-input').value.trim();
            playerName = (inputVal !== "") ? inputVal.toUpperCase() : "GUEST";
            document.getElementById('main-menu').style.display = 'none';
            giocoAttivo = gameName;

            if (gameName === 'maze') {
                document.getElementById('maze-wrapper').style.display = 'block';
                document.getElementById('maze-overlay').style.display = 'none';
                mazeStartTime = Date.now();
                if(mazeTimerInterval) clearInterval(mazeTimerInterval);
                mazeTimerInterval = setInterval(updateMazeTimerUI, 1000);
                updateMazeTimerUI();
                loadMazeLevel(0);
            } else if (gameName === 'fighter') {
                document.getElementById('fighter-wrapper').style.display = 'block';
                document.getElementById('fighter-overlay').style.display = 'none';
                startFighterGame();
            }
        }

        function goBack() {
            document.getElementById('maze-wrapper').style.display = 'none';
            document.getElementById('fighter-wrapper').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            giocoAttivo = 'menu';
            stopFighterGame();
            if(mazeTimerInterval) clearInterval(mazeTimerInterval);
        }

        // --- GAME LOOP ---
        function gameLoop() {
            const gp = navigator.getGamepads()[0];
            if (gp) {
                inputX = gp.axes[0];
                inputY = gp.axes[1];
            }

            if (Math.abs(inputX) < DEADZONE) inputX = 0;
            if (Math.abs(inputY) < DEADZONE) inputY = 0;

            if (giocoAttivo === 'maze') {
                if (document.getElementById('maze-overlay').style.display !== 'block') {
                    moveMazePlayer();
                }
            } else if (giocoAttivo === 'fighter') {
                if (!isFighterPaused && document.getElementById('fighter-overlay').style.display !== 'block') {
                    moveFighterPlayer();
                }
            }
            requestAnimationFrame(gameLoop);
        }
        gameLoop();

        // --- MOVIMENTO LABIRINTO (CON ANIMAZIONE 0.2s) ---
        let mazeMoveCooldown = 0;
        const MAZE_DELAY = 220; // Leggermente pi√π alto dell'animazione (200ms)

        function moveMazePlayer() {
            if (Date.now() - mazeMoveCooldown < MAZE_DELAY) return; 

            let dir = null;
            if (inputY < -0.5) dir = "SU";
            else if (inputY > 0.5) dir = "GIU";
            else if (inputX < -0.5) dir = "SINISTRA";
            else if (inputX > 0.5) dir = "DESTRA";

            if (dir) {
                attemptMazeMove(dir);
                mazeMoveCooldown = Date.now();
            }
        }

        // --- MOVIMENTO FIGHTER (VELOCIT√Ä RIDOTTA) ---
        // Prima era 15, ora √® 8 per maggiore controllo
        const FIGHTER_MAX_SPEED = 8; 
        
        function moveFighterPlayer() {
            let speed = inputX * FIGHTER_MAX_SPEED;
            fighterX += speed;
            if (fighterX < 0) fighterX = 0;
            if (fighterX > 370) fighterX = 370;
            updateFighterPos();
        }

        // =========================================================
        //                 SERIALE ARDUINO
        // =========================================================
        let port, reader;
        document.getElementById('connectBtn').addEventListener('click', async () => {
            if ("serial" in navigator) {
                try {
                    port = await navigator.serial.requestPort();
                    await port.open({ baudRate: 9600 });
                    const textDecoder = new TextDecoderStream();
                    port.readable.pipeTo(textDecoder.writable);
                    reader = textDecoder.readable.getReader();
                    document.getElementById('status').innerText = "‚úÖ CONNESSO";
                    document.getElementById('status').style.color = "var(--success)";
                    readSerialLoop();
                } catch (err) { alert("Errore USB: " + err); }
            }
        });

        async function readSerialLoop() {
            let buffer = ""; 
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                    buffer += value;
                    if (buffer.includes('\n')) {
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); 
                        for (let line of lines) {
                            if (line.includes(',')) parseArduinoData(line.trim());
                        }
                    }
                }
            }
        }

        function parseArduinoData(line) {
            let parts = line.split(',');
            if (parts.length === 2) {
                let rawX = parseInt(parts[0]);
                let rawY = parseInt(parts[1]);
                inputX = (rawX - 512) / 512.0; 
                inputY = (rawY - 512) / 512.0;
            }
        }

        // =========================================================
        //                 LOGICA DI GIOCO
        // =========================================================
        
        // --- MAZE ---
        const mazeCellSize = 30;
        let mazeMap = []; let mazeX = 1; let mazeY = 1; let currentLevel = 0;
        const mazeLevels = [
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1],[1,0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[1,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,1,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1],[1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],[1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,0,1],[1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1],[1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],[1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1],[1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,2,1],[1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1],[1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1],[1,0,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,1],[1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,0,0,0,0,1],[1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
        ];

        function loadMazeLevel(idx) {
            if (idx >= mazeLevels.length) { showMazeLeaderboard(false); idx = 0; return; }
            currentLevel = idx; mazeMap = mazeLevels[idx]; mazeX = 1; mazeY = 1;
            document.getElementById('maze-level-num').innerText = (idx + 1);
            const area = document.getElementById('game-area-maze');
            area.innerHTML = ''; area.style.width = (mazeMap[0].length * mazeCellSize) + "px";
            area.style.height = (mazeMap.length * mazeCellSize) + "px";
            area.style.gridTemplateColumns = `repeat(${mazeMap[0].length}, ${mazeCellSize}px)`;
            area.style.gridTemplateRows = `repeat(${mazeMap.length}, ${mazeCellSize}px)`;
            for(let r=0; r<mazeMap.length; r++) {
                for(let c=0; c<mazeMap[0].length; c++) {
                    const d = document.createElement('div'); d.classList.add('cell');
                    if(mazeMap[r][c]===1) d.classList.add('wall');
                    if(mazeMap[r][c]===2) d.classList.add('goal');
                    area.appendChild(d);
                }
            }
            const player = document.createElement('div'); player.id='player-maze';
            player.style.width = (mazeCellSize-6)+"px"; player.style.height = (mazeCellSize-6)+"px"; player.style.margin = "3px";
            area.appendChild(player);
            updateMazePlayer();
        }

        function attemptMazeMove(dir) {
            let nx = mazeX; let ny = mazeY;
            if(dir==="SU") ny--; if(dir==="GIU") ny++; if(dir==="SINISTRA") nx--; if(dir==="DESTRA") nx++;
            if(ny>=0 && ny<mazeMap.length && nx>=0 && nx<mazeMap[0].length) {
                if(mazeMap[ny][nx] === 0) {
                    mazeX=nx; mazeY=ny; updateMazePlayer();
                } else if(mazeMap[ny][nx] === 1) {
                    document.getElementById('game-area-maze').style.borderColor = "red";
                    setTimeout(()=>document.getElementById('game-area-maze').style.borderColor="#555", 200);
                    mazeX=1; mazeY=1; updateMazePlayer();
                } else if(mazeMap[ny][nx] === 2) {
                    mazeX=nx; mazeY=ny; updateMazePlayer();
                    setTimeout(()=>loadMazeLevel(currentLevel+1), 200);
                }
            }
        }
        function updateMazePlayer() {
            const p = document.getElementById('player-maze');
            p.style.top = (mazeY * mazeCellSize) + "px"; p.style.left = (mazeX * mazeCellSize) + "px";
        }

        // --- CLASSIFICHE & MENU ---
        function updateMazeTimerUI() { if(giocoAttivo === 'maze') document.getElementById('maze-live-timer').innerText = formatTime(Date.now() - mazeStartTime); }
        function getMazeTimes() { return JSON.parse(localStorage.getItem('maze_times_v1')) || []; }
        function saveMazeTime(msTime) { let scores = getMazeTimes(); scores.push({ name: playerName, time: msTime }); scores.sort((a,b)=>a.time-b.time); localStorage.setItem('maze_times_v1', JSON.stringify(scores)); }
        function showMazeLeaderboard(isPause) {
            if(!isPause) { saveMazeTime(Date.now()-mazeStartTime); if(mazeTimerInterval) clearInterval(mazeTimerInterval); }
            renderMazeList(getMazeTimes());
            document.getElementById('maze-overlay').style.display = 'block';
        }
        function renderMazeList(list) {
            const container = document.getElementById('maze-leaderboard-list'); container.innerHTML = "";
            list.forEach((entry, index) => {
                container.innerHTML += `<div class="leader-row"><span class="leader-rank">#${index+1}</span><span class="leader-name">${entry.name}</span><span class="leader-score">${formatTime(entry.time)}</span><span class="dots-menu-btn" onclick="toggleMenu('maze', ${index})">‚ãÆ</span><div id="maze-menu-${index}" class="dropdown-content"><div onclick="editEntry('maze', ${index})">Modifica</div><div onclick="deleteEntry('maze', ${index})" style="color:#f55">Elimina</div></div></div>`;
            });
        }
        function getFighterScores() { return JSON.parse(localStorage.getItem('fighter_scores_v1')) || []; }
        function saveFighterScore(score) { let scores = getFighterScores(); if(score!==null) { scores.push({name:playerName, score:score}); scores.sort((a,b)=>b.score-a.score); localStorage.setItem('fighter_scores_v1', JSON.stringify(scores)); } return scores; }
        function showFighterLeaderboard(score, isOver) {
            const list = saveFighterScore(isOver ? score : null);
            renderFighterList(list);
            document.getElementById('fighter-overlay').style.display = 'block';
            document.getElementById('final-score').innerText = isOver ? "Punti: "+score : "Punti: "+fighterScore;
            document.getElementById('fighter-resume-btn').style.display = isOver ? 'none' : 'block';
            document.getElementById('fighter-restart-btn').style.display = isOver ? 'block' : 'none';
        }
        function renderFighterList(list) {
            const container = document.getElementById('fighter-leaderboard-list'); container.innerHTML = "";
            list.forEach((entry, index) => {
                container.innerHTML += `<div class="leader-row"><span class="leader-rank">#${index+1}</span><span class="leader-name">${entry.name}</span><span class="leader-score">${entry.score}</span><span class="dots-menu-btn" onclick="toggleMenu('fighter', ${index})">‚ãÆ</span><div id="fighter-menu-${index}" class="dropdown-content"><div onclick="editEntry('fighter', ${index})">Modifica</div><div onclick="deleteEntry('fighter', ${index})" style="color:#f55">Elimina</div></div></div>`;
            });
        }
        function toggleMenu(type, idx) {
            let el = document.getElementById(`${type}-menu-${idx}`);
            let prev = el.style.display;
            document.querySelectorAll('.dropdown-content').forEach(d=>d.style.display='none');
            el.style.display = (prev==='block') ? 'none' : 'block';
        }
        window.onclick = e => { if(!e.target.matches('.dots-menu-btn')) document.querySelectorAll('.dropdown-content').forEach(d=>d.style.display='none'); }
        
        function deleteEntry(type, idx) {
            let key = type==='maze' ? 'maze_times_v1' : 'fighter_scores_v1';
            let list = JSON.parse(localStorage.getItem(key));
            list.splice(idx,1); localStorage.setItem(key, JSON.stringify(list));
            if(type==='maze') showMazeLeaderboard(true); else showFighterLeaderboard(null, false);
        }
        function editEntry(type, idx) {
            let key = type==='maze' ? 'maze_times_v1' : 'fighter_scores_v1';
            let list = JSON.parse(localStorage.getItem(key));
            let newName = prompt("Nome:", list[idx].name);
            if(newName) { list[idx].name = newName.toUpperCase().substring(0,8); localStorage.setItem(key, JSON.stringify(list)); 
            if(type==='maze') showMazeLeaderboard(true); else showFighterLeaderboard(null, false); }
        }
        function clearMazeLeaderboard() { if(confirm("Reset Classifica Labirinto?")) { localStorage.removeItem('maze_times_v1'); renderMazeList([]); } }
        function clearFighterLeaderboard() { if(confirm("Reset Classifica Fighter?")) { localStorage.removeItem('fighter_scores_v1'); renderFighterList([]); } }
        function closeMazeLeaderboard() { document.getElementById('maze-overlay').style.display = 'none'; }

        // --- FIGHTER ---
        let fighterX = 185; let fighterScore = 0; let fighterLoopId; let bullets = []; let enemies = []; let enemySpeed = 2;
        function startFighterGame() {
            fighterX = 185; fighterScore = 0; isFighterPaused = false; bullets = []; enemies = []; enemySpeed = 2;
            document.getElementById('score-board').innerText = "0000";
            const area = document.getElementById('game-area-fighter'); area.innerHTML = '<div id="fighter-player"></div>';
            updateFighterPos();
            if(fighterLoopId) clearInterval(fighterLoopId);
            fighterLoopId = setInterval(gameLoopFighter, 20);
        }
        function stopFighterGame() { clearInterval(fighterLoopId); }
        function updateFighterPos() { document.getElementById('fighter-player').style.transform = `translateX(${fighterX}px)`; }
        
        let frameCount = 0;
        function gameLoopFighter() {
            frameCount++;
            if (frameCount % 20 === 0) createBullet();
            if (frameCount % 50 === 0) createEnemy();
            
            enemySpeed = 2 + Math.floor(fighterScore / 100);
            if(enemySpeed>15) enemySpeed=15;
            document.getElementById('score-board').innerText = fighterScore;

            bullets.forEach((b, i) => {
                b.y -= 7; b.el.style.top = b.y + "px";
                if(b.y < -10) { b.el.remove(); bullets.splice(i,1); }
            });

            enemies.forEach((e, i) => {
                e.y += enemySpeed; e.el.style.top = e.y + "px";
                if(e.y > 470) { stopFighterGame(); showFighterLeaderboard(fighterScore, true); }
                
                bullets.forEach((b, j) => {
                    if(isColliding(b,e)) {
                        fighterScore += 10; e.el.remove(); b.el.remove();
                        enemies.splice(i,1); bullets.splice(j,1);
                    }
                });
                if(isColliding({x:fighterX, y:450, w:30, h:30}, e)) {
                    e.el.remove(); enemies.splice(i,1);
                }
            });
        }
        function createBullet() {
            const b = document.createElement('div'); b.className = 'bullet';
            let bx = fighterX+13; let by=450; b.style.left=bx+"px"; b.style.top=by+"px";
            document.getElementById('game-area-fighter').appendChild(b);
            bullets.push({el:b, x:bx, y:by, w:4, h:15});
        }
        function createEnemy() {
            const e = document.createElement('div'); e.className = 'enemy';
            let ex = Math.random()*370; let ey=-30; e.style.left=ex+"px"; e.style.top=ey+"px";
            document.getElementById('game-area-fighter').appendChild(e);
            enemies.push({el:e, x:ex, y:ey, w:30, h:30});
        }
        function isColliding(a,b) { return !(a.y+a.h < b.y || a.y > b.y+b.h || a.x+a.w < b.x || a.x > b.x+b.w); }
        function pauseAndShowFighterLeaderboard() { if(document.getElementById('fighter-overlay').style.display === 'block') return; isFighterPaused=true; clearInterval(fighterLoopId); showFighterLeaderboard(fighterScore, false); }
        function resumeFighter() { document.getElementById('fighter-overlay').style.display='none'; isFighterPaused=false; fighterLoopId=setInterval(gameLoopFighter,20); }
        function restartFighter() { document.getElementById('fighter-overlay').style.display='none'; isFighterPaused=false; startFighterGame(); }

    </script>
</body>
</html>
